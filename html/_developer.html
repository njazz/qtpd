<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>qtpd: Developer</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">qtpd
   
   </div>
   <div id="projectbrief">Puredata Qt-based GUI</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Developer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Interface"></a>
Interface</h2>
<p>The main interface to <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> is the <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> singleton. <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> needs to be initialized via <a class="el" href="class_python_qt.html#a2cc06e2e12ebd389504e3ce6a1751c3e">PythonQt::init()</a> once. Afterwards you communicate with the singleton via <a class="el" href="class_python_qt.html#a55184a6cb954afb65e2d6f9ae56b0b0a" title="get the singleton instance">PythonQt::self()</a>. <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> offers a complete Qt binding, which needs to be enabled via <a class="el" href="namespace_python_qt___qt_all.html#a2ab1ae5db205d024de26add8942e8591" title="initialize the Qt binding">PythonQt_QtAll::init()</a>.</p>
<h2><a class="anchor" id="Datatype"></a>
Datatype Mapping</h2>
<p>The following table shows the mapping between Python and Qt objects: </p>
<table class="doxtable">
<tr>
<th>Qt/C++</th><th>Python </th></tr>
<tr>
<td>bool</td><td>bool </td></tr>
<tr>
<td>double</td><td>float </td></tr>
<tr>
<td>float</td><td>float </td></tr>
<tr>
<td>char/uchar,int/uint,short,ushort,QChar</td><td>integer </td></tr>
<tr>
<td>long</td><td>integer </td></tr>
<tr>
<td>ulong,longlong,ulonglong</td><td>long </td></tr>
<tr>
<td>QString</td><td>unicode string </td></tr>
<tr>
<td>QByteArray</td><td>QByteArray wrapper </td></tr>
<tr>
<td>char*</td><td>str </td></tr>
<tr>
<td>QStringList</td><td>tuple of unicode strings </td></tr>
<tr>
<td>QVariantList</td><td>tuple of objects </td></tr>
<tr>
<td>QVariantMap</td><td>dict of objects </td></tr>
<tr>
<td>QVariant</td><td>depends on type, see below </td></tr>
<tr>
<td>QSize, QRect and all other standard Qt QVariants</td><td>variant wrapper that supports complete API of the respective Qt classes </td></tr>
<tr>
<td>OwnRegisteredMetaType</td><td>C++ wrapper, optionally with additional information/wrapping provided by registerCPPClass() </td></tr>
<tr>
<td>QList&lt;AnyObject*&gt;</td><td>converts to a list of CPP wrappers </td></tr>
<tr>
<td>QVector&lt;AnyObject*&gt;</td><td>converts to a list of CPP wrappers </td></tr>
<tr>
<td>EnumType</td><td>Enum wrapper derived from python integer </td></tr>
<tr>
<td>QObject (and derived classes)</td><td>QObject wrapper </td></tr>
<tr>
<td>C++ object</td><td>CPP wrapper, either wrapped via <a class="el" href="class_python_qt_cpp_wrapper_factory.html" title="Factory interface for C++ classes that can be wrapped by QObject objects.">PythonQtCppWrapperFactory</a> or just decorated with decorators </td></tr>
<tr>
<td>PyObject</td><td>PyObject </td></tr>
</table>
<p>PyObject is passed as direct pointer, which allows to pass/return any Python object directly to/from a Qt slot that uses PyObject* as its argument/return value. QVariants are mapped recursively as given above, e.g. a dictionary can contain lists of dictionaries of doubles. All Qt QVariant types are implemented, <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> supports the complete Qt API for these object.</p>
<h2><a class="anchor" id="QObject"></a>
QObject Wrapping</h2>
<p>All classes derived from QObject are automatically wrapped with a python wrapper class when they become visible to the Python interpreter. This can happen via</p>
<ul>
<li>the <a class="el" href="class_python_qt.html#a8134a601594d09b76aad66da3e75803d" title="add the given qObject to the python object as a variable with name (it can be removed via clearVariab...">PythonQt::addObject()</a> method</li>
<li>when a Qt <b>slot</b> returns a QObject derived object to python</li>
<li>when a Qt <b>signal</b> contains a QObject and is connected to a python function</li>
</ul>
<p>It is important that you call <a class="el" href="class_python_qt.html#a1d50946ef76058e9e9ca37e99cdc16a2" title="registers a QObject derived class to PythonQt (this is implicitly called by addObject as well)...">PythonQt::registerClass()</a> for any QObject derived class that may become visible to Python, except when you add it via <a class="el" href="class_python_qt.html#a8134a601594d09b76aad66da3e75803d" title="add the given qObject to the python object as a variable with name (it can be removed via clearVariab...">PythonQt::addObject()</a>. This will register the complete parent hierachy of the registered class, so that when you register e.g. a QPushButton, QWidget will be registered as well (and all intermediate parents).</p>
<p>From Python, you can talk to the returned QObjects in a natural way by calling their slots and receiving the return values. You can also read/write all properties of the objects as if they where normal python properties.</p>
<p>In addition to this, the wrapped objects support</p>
<ul>
<li>className() - returns a string that reprents the classname of the QObject</li>
<li>help() - shows all properties, slots, enums, decorator slots and constructors of the object, in a printable form</li>
<li>delete() - deletes the object (use with care, especially if you passed the ownership to C++)</li>
<li>connect(signal, function) - connect the signal of the given object to a python function</li>
<li>connect(signal, qobject, slot) - connect the signal of the given object to a slot of another QObject</li>
<li>disconnect(signal, function) - disconnect the signal of the given object from a python function</li>
<li>disconnect(signal, qobject, slot) - disconnect the signal of the given object from a slot of another QObject</li>
<li>children() - returns the children of the object</li>
<li>setParent(QObject) - set the parent</li>
<li>QObject* parent() - get the parent</li>
</ul>
<p>The below example shows how to connect signals in Python:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # define a signal handler function</span>
<span class="preprocessor"></span> def someFunction(flag):
   print flag

 # button1 is a QPushButton that has been added to Python via addObject()
 # connect the clicked signal to a python function:
 button1.connect(<span class="stringliteral">&quot;clicked(bool)&quot;</span>, someFunction)
</pre></div><h2><a class="anchor" id="CPP"></a>
CPP Wrapping</h2>
<p>You can create dedicated wrapper QObjects for any C++ class. This is done by deriving from <a class="el" href="class_python_qt_cpp_wrapper_factory.html" title="Factory interface for C++ classes that can be wrapped by QObject objects.">PythonQtCppWrapperFactory</a> and adding your factory via addWrapperFactory(). Whenever <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> encounters a CPP pointer (e.g. on a slot or signal) and it does not known it as a QObject derived class, it will create a generic CPP wrapper. So even unknown C++ objects can be passed through Python. If the wrapper factory supports the CPP class, a QObject wrapper will be created for each instance that enters Python. An alternative to a complete wrapper via the wrapper factory are decorators, see <a class="el" href="_developer.html#Decorators">Decorator slots</a></p>
<h2><a class="anchor" id="MetaObject"></a>
Meta Object/Class access</h2>
<p>For each known C++ class, <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> provides a Python class. These classes are visible inside of the "PythonQt" python module or in subpackages if a package is given when the class is registered.</p>
<p>A Meta class supports:</p>
<ul>
<li>access to all declared enum values</li>
<li>constructors</li>
<li>static methods</li>
<li>unbound non-static methods</li>
<li>help() and className()</li>
</ul>
<p>From within Python, you can import the module "PythonQt" to access these classes and the Qt namespace.</p>
<div class="fragment"><pre class="fragment">from <a class="code" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> <span class="keyword">import</span> QtCore

<span class="preprocessor"># namespace access:</span>
<span class="preprocessor"></span>print QtCore.Qt.AlignLeft

<span class="preprocessor"># constructors</span>
<span class="preprocessor"></span>a = QtCore.QSize(12,13)
b = QtCore.QFont()

<span class="preprocessor"># static method</span>
<span class="preprocessor"></span>QtCore.QDate.currentDate()

<span class="preprocessor"># enum value</span>
<span class="preprocessor">QtCore.QFont.UltraCondensed</span>
</pre></div><h2><a class="anchor" id="Decorators"></a>
Decorator slots</h2>
<p><a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> introduces a new generic approach to extend any wrapped QObject or CPP object with</p>
<ul>
<li>constructors</li>
<li>destructors (for CPP objects)</li>
<li>additional slots</li>
<li>static slots (callable on both the Meta object and the instances)</li>
</ul>
<p>The idea behind decorators is that we wanted to make it as easy as possible to extend wrapped objects. Since we already have an implementation for invoking any Qt Slot from Python, it looked promising to use this approach for the extension of wrapped objects as well. This avoids that the <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> user needs to care about how Python arguments are mapped from/to Qt when he wants to create static methods, constructors and additional member functions.</p>
<p>The basic idea about decorators is to create a QObject derived class that implements slots which take one of the above roles (e.g. constructor, destructor etc.) via a naming convention. These slots are then assigned to other classes via the naming convention.</p>
<ul>
<li>SomeClassName* new_SomeClassName(...) - defines a constructor for "SomeClassName" that returns a new object of type SomeClassName (where SomeClassName can be any CPP class, not just QObject classes)</li>
<li>void delete_SomeClassName(SomeClassName* o) - defines a destructor, which should delete the passed in object o</li>
<li>anything static_SomeClassName_someMethodName(...) - defines a static method that is callable on instances and the meta class</li>
<li>anything someMethodName(SomeClassName* o, ...) - defines a slot that will be available on SomeClassName instances (and derived instances). When such a slot is called the first argument is the pointer to the instance and the rest of the arguments can be used to make a call on the instance.</li>
</ul>
<p>The below example shows all kinds of decorators in action:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// an example CPP object</span>
<span class="keyword">class </span>YourCPPObject {
<span class="keyword">public</span>:
  YourCPPObject(<span class="keywordtype">int</span> arg1, <span class="keywordtype">float</span> arg2) { a = arg1; b = arg2; }

  <span class="keywordtype">float</span> doSomething(<span class="keywordtype">int</span> arg1) { <span class="keywordflow">return</span> arg1*a*b; };

  <span class="keyword">private</span>:

  <span class="keywordtype">int</span> a;
  <span class="keywordtype">float</span> b;
};

<span class="comment">// an example decorator</span>
<span class="keyword">class </span>ExampleDecorator : <span class="keyword">public</span> QObject
{
  Q_OBJECT

<span class="keyword">public</span> slots:
  <span class="comment">// add a constructor to QSize that takes a QPoint</span>
  QSize* new_QSize(<span class="keyword">const</span> QPoint&amp; <a class="code" href="floatobject_8h.html#af18a92ce774f4c499544fbcc894db7e8">p</a>) { <span class="keywordflow">return</span> <span class="keyword">new</span> QSize(p.x(), p.y()); }

  <span class="comment">// add a constructor for QPushButton that takes a text and a parent widget</span>
  QPushButton* new_QPushButton(<span class="keyword">const</span> QString&amp; text, QWidget* parent=NULL) { <span class="keywordflow">return</span> <span class="keyword">new</span> QPushButton(text, parent); }

  <span class="comment">// add a constructor for a CPP object</span>
  YourCPPObject* new_YourCPPObject(<span class="keywordtype">int</span> arg1, <span class="keywordtype">float</span> arg2) { <span class="keywordflow">return</span> <span class="keyword">new</span> YourCPPObject(arg1, arg2); }

  <span class="comment">// add a destructor for a CPP object</span>
  <span class="keywordtype">void</span> delete_YourCPPObject(YourCPPObject* <a class="code" href="abstract_8h.html#aaa12580403a2cc24c96324b4c5715889">obj</a>) { <span class="keyword">delete</span> <a class="code" href="abstract_8h.html#aaa12580403a2cc24c96324b4c5715889">obj</a>; }

  <span class="comment">// add a static method to QWidget</span>
  QWidget* static_QWidget_mouseGrabber() { <span class="keywordflow">return</span> QWidget::mouseGrabber(); }

  <span class="comment">// add an additional slot to QWidget (make move() callable, which is not declared as a slot in QWidget)</span>
  <span class="keywordtype">void</span> move(QWidget* w, <span class="keyword">const</span> QPoint&amp; p) { w-&gt;move(p); }

  <span class="comment">// add an additional slot to QWidget, overloading the above move method</span>
  <span class="keywordtype">void</span> move(QWidget* w, <span class="keywordtype">int</span> <a class="code" href="stringobject_8h.html#a280f2393c503127fff91ecbc558e288d">x</a>, <span class="keywordtype">int</span> y) { w-&gt;move(x,y); }

  <span class="comment">// add a method to your own CPP object</span>
  <span class="keywordtype">int</span> doSomething(YourCPPObject* <a class="code" href="abstract_8h.html#aaa12580403a2cc24c96324b4c5715889">obj</a>, <span class="keywordtype">int</span> arg1) { <span class="keywordflow">return</span> obj-&gt;doSomething(arg1); }
};

...

PythonQt::self()-&gt;addDecorators(<span class="keyword">new</span> ExampleDecorator());
<a class="code" href="class_python_qt.html#a55184a6cb954afb65e2d6f9ae56b0b0a" title="get the singleton instance">PythonQt::self</a>()-&gt;<a class="code" href="class_python_qt.html#a97559c89bfed5f0f5bb47d7fc360a269">registerCPPClass</a>(<span class="stringliteral">&quot;YourCPPObject&quot;</span>);
</pre></div><p>After you have registered an instance of the above ExampleDecorator, you can do the following from Python (all these calls are mapped to the above decorator slots):</p>
<div class="fragment"><pre class="fragment">from <a class="code" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> <span class="keyword">import</span> QtCore, QtGui, YourCPPObject

<span class="preprocessor"># call our new constructor of QSize</span>
<span class="preprocessor"></span><a class="code" href="bufferobject_8h.html#a612c27dae5681d14a5d92d0b3d8ab6e5">size</a> = QtCore.QSize(QPoint(1,2));

<span class="preprocessor"># call our new QPushButton constructor</span>
<span class="preprocessor"></span>button = QtGui.QPushButton(<span class="stringliteral">&quot;sometext&quot;</span>);

<span class="preprocessor"># call the move slot (overload1)</span>
<span class="preprocessor"></span>button.move(QPoint(0,0))

<span class="preprocessor"># call the move slot (overload2)</span>
<span class="preprocessor"></span>button.move(0,0)

<span class="preprocessor"># call the static method</span>
<span class="preprocessor"></span>grabber = QtGui.QWidget.mouseWrapper();

<span class="preprocessor"># create a CPP object via constructor</span>
<span class="preprocessor"></span>yourCpp = YourCPPObject(1,11.5)

<span class="preprocessor"># call the wrapped method on CPP object</span>
<span class="preprocessor"></span>print yourCpp.doSomething(1);

<span class="preprocessor"># destructor will be called:</span>
<span class="preprocessor">yourCpp = None</span>
</pre></div><h2><a class="anchor" id="Ownership"></a>
Ownership management</h2>
<p>In <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a>, each wrapped C++ object is either owned by Python or C++. When an object is created via a Python constructor, it is owned by Python by default. When an object is returned from a C++ API (e.g. a slot), it is owned by C++ by default. Since the Qt API contains various APIs that pass the ownership from/to other C++ objects, <a class="el" href="class_python_qt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> needs to keep track of such API calls. This is archieved by annotating arguments and return values in wrapper slots with magic templates:</p>
<ul>
<li><a class="el" href="class_python_qt_pass_ownership_to_c_p_p.html">PythonQtPassOwnershipToCPP</a></li>
<li><a class="el" href="class_python_qt_pass_ownership_to_python.html">PythonQtPassOwnershipToPython</a></li>
<li><a class="el" href="class_python_qt_new_owner_of_this.html">PythonQtNewOwnerOfThis</a></li>
</ul>
<p>These annotation templates work for since C++ pointer types. In addition to that, they work for QList&lt;AnyObject*&gt;, to pass the ownership for each object in the list.</p>
<p>Examples: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">public</span> slots:
   <a class="code" href="class_python_qt_pass_ownership_to_python.html">PythonQtPassOwnershipToPython&lt;QGraphicsItem*&gt;</a> createNewItemOwnedByPython();

   <span class="keywordtype">void</span> addItemToCPP(<a class="code" href="class_python_qt_pass_ownership_to_python.html">PythonQtPassOwnershipToPython&lt;QGraphicsItem*&gt;</a> <a class="code" href="dictobject_8h.html#a54447cc31a87ae88effdc512eb6d5496">item</a>);

   <span class="keywordtype">void</span> addItemToCPP(<a class="code" href="class_python_qt_pass_ownership_to_python.html">PythonQtPassOwnershipToPython</a>&lt;QList&lt;QGraphicsItem*&gt; &gt; items);

   <span class="keywordtype">void</span> addItemParent(QGraphicsItem* wrappedObject, <a class="code" href="class_python_qt_new_owner_of_this.html">PythonQtNewOwnerOfThis&lt;QGraphicsItem*&gt;</a> parent);
</pre></div> </div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 16 2017 14:25:22 for qtpd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
